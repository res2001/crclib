/*
 * Вычисление контрольных сумм.
 */

#include "crc.h"


/*===============================================================================================*/
#if defined(LES_CRC)
/*-----------------------------------------------------------------------------------------------*/
unsigned short eval_crc16(unsigned short crc, const unsigned char *msg, unsigned msg_len)
{
	/* Вычисление 16-разрядного циклического избыточного кода (ЦИК - CRC)
	*  crc     - исходное значение ЦИК, 0 при первом вызове
	*  msg     - указатель блока сообщения
	*  msg_len - число байтов в блоке
	*  Возвращает 16-разрядный ЦИК
	*/
	
	const unsigned short crc_poly = 0x1021;			/* порождающий многочлен */
	unsigned char        j;
	
	
	while (msg_len-- > 0)
	{
		crc ^= (unsigned short)*msg++ << 8;
		
		for (j = 8; j > 0; j--)				/* проверка каждого бита */
		{
			if (crc & 0x8000)
			{
				crc = crc << 1 ^ crc_poly;
			}
			else
			{
				crc <<= 1;
			}
		}
	}
	
	return crc & 0xffff;
}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
unsigned char eval_crc8(unsigned char crc, const unsigned char *msg, unsigned msg_len)
{
	/*
	 * Расчет 8-битной контрольной суммы.
	 * ОПИСАНИЕ
	 *   Вычисляется 8-битный циклический избыточный код.
	 * ПАРАМЕТРЫ
	 *   crc     - начальное значение контрольной суммы (при первом вызове должно быть равно 0);
	 *   msg     - указатель на массив данных, по которым вычисляется контрольная сумма;
	 *   msg_len - длина обрабатываемого массива.
	 * ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
	 *   Полученное значение 8-битной контрольной суммы.
	 */

	const unsigned char crc8_poly = 0x8c;		/* порождающий полином для 8-битной CRC */
	unsigned char       j;


	while (msg_len-- > 0)
	{
		crc ^= *msg++;
		for (j = 8; j > 0; j--)
		{
			if (crc & 0x80)	crc = (crc << 1) ^ crc8_poly;
			else            crc <<= 1;
		}
	}
	
	return crc & 0xff;
}
/*-----------------------------------------------------------------------------------------------*/

#ifdef REV_CRC
/*-----------------------------------------------------------------------------------------------*/
unsigned char eval_revcrc8(unsigned char crc, const unsigned char *msg, unsigned msg_len)
{
	/*
	 * Расчет 8-битной контрольной суммы.
	 * ОПИСАНИЕ
	 *   Вычисляется 8-битный циклический избыточный код.
	 * ПАРАМЕТРЫ
	 *   crc     - начальное значение контрольной суммы (при первом вызове должно быть равно 0);
	 *   msg     - указатель на массив данных, по которым вычисляется контрольная сумма;
	 *   msg_len - длина обрабатываемого массива.
	 * ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
	 *   Полученное значение 8-битной контрольной суммы.
	 */

	const unsigned char revcrc8_poly = 0x8c;		/* порождающий полином для 8-битной CRC */
	unsigned char       j;


	while (msg_len-- > 0)
	{
		crc ^= *msg++;
		for (j = 8; j > 0; j--)
		{
			if (crc & 0x01)	crc = (crc >> 1) ^ revcrc8_poly;
			else            crc >>= 1;
		}
	}
	
	return crc & 0xff;
}
/*-----------------------------------------------------------------------------------------------*/
#endif

#endif						/*#if defined(LES_CRC)*/
/*===============================================================================================*/
